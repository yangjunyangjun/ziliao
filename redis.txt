1、redis的基本数据类型
    字符串、队列、有序集合、无序集合、哈希
 
2、字符串类型的值最大只能存储512M
 
3、redis的淘汰策略
     a、volatile-lru 从设置了过期时间的数据集中淘汰最近使用较少的数据
     b、volatile-ttl 从设置了过期时间的数据集中淘汰快过期的数据
     c、volatile-random 从 设置了过期时间的数据集中随机淘汰数据
     
     d、allkeys-lru 从所有数据集中淘汰使用较少的数据
     e、allkeys-random 从所有数据中随机淘汰
     f、no-enviction   禁止淘汰数据
     
     不同场景使用不同淘汰策略，譬如： 所有数据访问频率差不多，选用 volatile-random ；一部分访问频率高，一部分访问频率低，选用volatile-lru 
     

4、redis 持久化
    RDB（BRedis DataBase）： 在某个时间点，用子进程把redis的数据保存在文件上
        优点：性能好，只有一个文件（全部是数据），磁盘占用少
        缺点：RDB是定时触发的，有时间间隔，可能在RDB时发生宕机，数据没那么精确
    
    AOF （Append-only file）：redis每个命令动作都会被追加到备份文件上
        优点：数据安全
        缺点：备份文件较大，恢复数据慢


5、删除策略
     a、定时删除（性能不好，有若干个定时key，就有多个定时任务）：设置过期时间时，会新建一个定时任务，当时间到了之后会执行删除
     b、惰性删除：设置过期时间之后就不管。等到获取这个key时判断是否过期，如果过期就删除，没过期则返回这个key的值
     c、定期删除：每隔一段时间会随机从库中拿到一批key进行扫描，检查是否过期，过期就会删除
     

6、怎么保证数据的一致性（redis和db）
    发生场景：更新数据时，数据库数据被更新了，缓存还没更新，会造成脏数据
    解决方案：更新DB之前，先把redis缓存删除，更新成功之后再删一遍缓存
    
 
 7、缓存穿透
    发生场景：再高并发的场景下，如果大量请求同时查询某个不存在的数据，因为redis缓存不存在，那么大量请求将打到数据库上，会造成数据库压力很大
    解决方案：如果在数据库没找到数据，可以在redis把这个值设置为null，这样请求就不会到数据库去，要把这个key的过期时间设置短一点
    
 8、缓存雪崩
    发生场景：譬如，某个脚本同时设置一批key，过期时间都一样，如果在这些key过期期间有多个请求获取这些key，则全部压力都会到数据库
    解决方案：a、在设置过期时间时，可以在一个基础时间上再加一个随机时间，把这些key分散，
             b、或者设置永不过期，定时脚本去更新这些key
 
 9、缓存击穿
  发生场景：高并发场景下，某个key过期了，但是多个请求过来，会全部去数据库（缓存还没更新）
  解决方案：a 、将热点数据设置为永不过期，定时脚本去更新数据
           b、 使用分布式锁，只有拿到锁的请求才去数据库拿数据，其余请求等待。拿到数据之后通知其余请求去缓存拿数据
           
 10、分布式锁 （setnx expipe）。
      因为设置缓存和设置过期时间不是一个原子操作。可能设置key成功，设置过期时间失败，就会造成这个锁会一直被锁定
      把这两个操作当做原子操作来处理
      
 11、redis单线程为什么性能还这么好
       a、因为redis是基于内存的，不会有磁盘I/O
       b、单线程不切换上下文
       c、网络I/O 使用了多路复用


12、redis的集群
     a、主从模式： master写，  slave读 。  master挂了之后就没有主节点了，将不正正常工作
     b 哨兵模式：相较于主从模式，多了一个监控，监控各节点的健康状态，如果master节点挂了，会从slave选取一个为master
     c、Cluster模式：相当于分布式存储，能对redis动态扩容，但是一个节点挂了就会丢失这个节点的数据
