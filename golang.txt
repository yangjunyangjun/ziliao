1、空切片和nil切片的区别
   空切片可以给它扩容使用， nil切片不能使用
   nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址）
   空切片的引用数组指针地址是有的，且固定为一个值
   

2、关于channel的特性
  channel分为有缓冲和无缓冲，无缓冲是同步的，在发送之前必须要有个协程接收，不然会死锁，有缓冲是异步的
  向nil channel发送和接收数据会阻塞
  一个关闭的channel ：发送数据会panic ，接收数据,如果channel里还有数据能正常接收（data:ture:=<-chan), 如果没有数据会接收channel里数据类型的默认值（0,false:=<-chan int）
  重复关闭一个channel会panic
  
  
  3、字符串单引号和双引号
    双引号⽤来表示字符串 string，其实质是⼀个 byte 类型的数组，单引号表示 rune 类型
    字符串只能被访问，不能被修改，例如：a:="abc" a[0]="A",这是错误的
    
  
  4、字符串转成byte数组，会发⽣内存拷⻉吗？
   会发生内存拷贝，只要类型转换都会发生内存拷贝
   
  5、拷贝大切片比拷贝小切片代价大吗？
      拷贝所有切片代价是一样的，切片的组成是 （数组指针、长度、容量）
    
  6、golang能比较的类型
      字符串、布尔、数字、指针、数组、通道、接口、结构体，其余类型不能比较，如果要比较需要用反射
     
  7、golang常用的并发模型
      通过channel通知实现并发控制
      通过sync包中的WaitGroup实现并发控制
      在Go 1.7 以后引进的强⼤的Context上下⽂，实现并发控制
      
 8、协程，线程，进程的区别。
      进程
      进程是系统进⾏资源分配和调度的⼀个独⽴单位。每个进程都有⾃⼰的独⽴内存空间，但是切换进程开销⽐较⼤。
      线程
      线程是计算机调度的基本单位,每个线程有自己的栈空间，同一个进程中的线程共享堆内存。线程的上下文切换比较快，资源开销较少，但相⽐进
      程不够稳定容易丢失数据。
      协程
      协程是⼀种⽤户态的轻量级线程，协程的调度完全由⽤户控制。像golang中，创建一个协程只要2kb，上下文切换更快
      
 
9、关于切片的扩容
   如果切片容量大于1024，扩容量为原来1/4 ；小于1024扩容量为原来的2倍
   
   
 10、defer：延迟调用，先进先出
      函数return 和defer的顺序：将返回值保存在栈上>>> 执行defer函数（可以修改return的值）>>> 函数返回
      
 11、 空结构体
      在channel 的使用场景中，常常会遇到通知型 channel，其不需要发送任何数据，只是用于协调 Goroutine 的运行，用于流转各类状态或是控制并发情况。
      
 12、Golang的内存模型，为什么⼩对象多了会造成gc压⼒。
      通常⼩对象过多会导致GC三⾊法消耗过多的GPU。优化思路是，减少对象分配.
 
 13、new和make的区别
      new和make都是用来分配内存的，new只是分配内存，没有初始化，make分配内存并初始化。make用于 slice、map 、channel
      
 14、golang 值传递和指针传递的区别。
   值传递是复制一个值给函数，不会改变函数外面的值
   指针传递是把地址传给函数，会改变函数外面的值
   一般情况下，能用值传递绝不用指针传递，避免内存逃逸
   
 15、go的锁类型
     锁的两种模式：正常模式，饥饿模式（长时间会获取到锁，会进入饥饿模式）
 
     互斥锁(sync.Mutex)：互斥锁是一种混合锁，其实现方式包含了自旋锁，同时参考了操作系统锁的实现
     
         互斥锁获取锁的步骤：
            a、使用原子操作快速抢占锁，如果成功立即返回
            b、抢占失败会进入自旋模式，自旋一段时间还是没有获取到锁，那么将进入休眠
            c、锁会放在全局的等待队列中，先进先出
            d、 当长时间无法获取到锁时，当前的互斥锁会进入饥饿模式，不用去和新申请的锁竞争，直接获取到锁
           
         自旋锁产生的条件：
            a、锁被占用，并且没有产生自旋
            b、	多核cpu, runtime.GOMAXPROCS大于1
            c、没有超过自旋设定的阈值
            d、当前协程所在的逻辑处理器p的本地队列没有其他协程待运行
     
     读写锁（sync.RWMutex）：分为写锁和读写锁
        获取到写锁之后，其余协程不管是读还是写都不是获取该锁
        获取到读锁之后，其余协程可以获取到读锁，但是不能获取写锁
        
    CAS原子操作，不用锁，用sync/atomic 包，因为原子操作性能更好
    什么是原子操作： 原子操作就是一个或多个操作在执行中不会被中断
    原子操作和锁的区别： 原子操作是由底层硬件支持，锁是由操作系统调度实现
    
    
 
 16、go的协程goroutine
         goroutine的栈空间为2kb，一般线程的栈空间为2MB，所有创建一个协程的开销很小，go的栈空间还可以动态的扩容
         
         goroutine切换时机
            a、主动调度：自己让出时间片（runtime.Gosched()）,一般不会用
            b、被动调度：协程在休眠、阻塞、网络I/O、垃圾回收等状态会让出时间片
            c、抢占式调度：当一个协程执行时间过长会被抢占
            
          
         GMP模型
            G:代表go语言中的协程goroutine
            M：实际的线程
            P：逻辑处理器，默认个数给cpu的个数，每个P都会有一个队列，队列不能超过256
            
            当创建一个goroutine，会把这个g放到P 中的一个队列中。如果P的队列满了会放在全局队列
            
            
            当需要调度时，会先从局部队列中拿一个g执行，如果当前局部队列中没有g了，那么会从全局队列中获取到局部队列（不能超过局部队列的一半 128），
            如果全局队列中也没有，则会尝试从其他P的队列中窃取
            work stealing 机制：当本线程无可以运行的G时，尝试从其余P对立中偷取G，而不是销毁线程
            hand off机制： 当一个线程阻塞，会把时间片让给空闲的线程
            
            
            
            golang调度器的策略：P中调度61次，会从全局队列中获取一个g放到局部队列中
            
    
    17、GC golang的垃圾回收（三色标记）: 分配和管理新对象，识别正在使用中的对象，清除不在使用的对象
            大对象：指大于32kb的对象
            垃圾回收会占用25%的cpu ，默认每2分钟执行一次或者达到回收的阈值
        
        
    18、Broadcast 和 Signal 区别 
           Broadcast 唤醒所有的goroutine
           Signal 唤醒一个goroutine

    19、内存逃逸 
            逃逸分析： go build -gcflags=-m , 可以看出哪些对象本该在栈上却被分配到堆上
            
            性能分析： pprof 做性能分析
